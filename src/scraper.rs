// Scraper does the following:
// - Takes spider start requests and passes them to the engine
// - Enqueues result from engine and passes back to the crawler
// - Handles spider output and error
// - Handles items generated by the spider
// - [Optional] Plugs in item processing middleware.
use crate::request::Request;
use crate::response::Response;
use crate::spider::Spider;
use tokio::sync::mpsc::{self, Receiver, Sender};

struct Scraper {
    response_tx: Sender<Response>,
    response_rx: Receiver<Response>,
    spider: Box<dyn Spider>,
}

impl Scraper {
    pub fn new(buffer: usize, spider: Box<dyn Spider>) -> Self {
        let (response_tx, response_rx) = mpsc::channel(buffer);
        Self {
            response_tx,
            response_rx,
            spider,
        }
    }

    pub async fn enqueue_response(
        &self,
        response: Response,
    ) -> Result<(), tokio::sync::mpsc::error::SendError<Response>> {
        self.response_tx.send(response).await
    }

    pub fn generate_start_requests(&self) -> impl Iterator<Item = Request> + '_ {
        self.spider.start().map(|req| {
            req.validate();
            req.as_start()
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::request::Request;

    struct TestSpider;

    impl Spider for TestSpider {
        fn start(&self) -> Box<dyn Iterator<Item = Request> + Send> {
            let url = "http://example.com";
            let request = Request::get(url);
            Box::new(vec![request].into_iter())
        }
    }

    #[tokio::test]
    async fn test_generate_start_requests_marks_requests_as_start() {
        let scraper = Scraper::new(10, Box::new(TestSpider));
        let mut requests = scraper.generate_start_requests();

        let req = requests.next().expect("Expected at least one request");
        assert!(
            req.is_start_request(),
            "Request was not marked as start request"
        );
    }

    struct BadSpider;

    impl Spider for BadSpider {
        fn start(&self) -> Box<dyn Iterator<Item = Request> + Send> {
            Box::new(vec![Request::default()].into_iter())
        }
    }

    #[test]
    #[should_panic(expected = "ValidationError: Callback cannot be empty")]
    fn test_generate_start_requests_panics_on_empty_callback() {
        let scraper = Scraper::new(10, Box::new(BadSpider));
        let mut requests = scraper.generate_start_requests();
        let _ = requests.next();
    }
}
