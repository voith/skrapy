// Scraper does the following:
// - Takes spider start requests and passes them to the engine
// - Handles spider output and error
// - Handles items generated by the spider
// - [Optional] Plugs in item processing middleware.
use crate::downloader::DownloadResult;
use crate::request::{CallbackReturn, Request};
use crate::response::Response;
use crate::spider::{Spider, SpiderOutput};

pub struct Scraper {
    spider: Box<dyn Spider>,
}

impl Scraper {
    pub fn new(spider: Box<dyn Spider>) -> Self {
        Self { spider }
    }

    pub fn generate_start_requests(&self) -> impl Iterator<Item = Request> + '_ {
        self.spider.start().map(|req| {
            req.validate();
            req.as_start()
        })
    }

    pub async fn process_response(&self, download_result: DownloadResult) -> CallbackReturn {
        let response = Response::from(download_result);
        // TODO(Voith):: Apply pre-process-response spider middleware
        (response.request.callback)(response)
    }

    pub async fn process_spider_output(&self, spider_output_iter: CallbackReturn) {
        for spider_output in spider_output_iter {
            match &spider_output {
                SpiderOutput::Item(item) => {
                    // TODO:: Implement ItemManager
                }
                SpiderOutput::Request(request) => {
                    // TODO:: Implement Spider Request Output handler
                }
            }
        }
    }

    fn is_idle() -> bool {
        // TODO(Voith): Use busy flags for process_response and process_spider_output
        false
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use reqwest::Response as ReqwestResponse;
    use std::sync::atomic::{AtomicBool, Ordering};

    static FLAG: AtomicBool = AtomicBool::new(false);

    // A simple function pointer callback that flips the flag
    fn dummy_callback(_: Response) -> CallbackReturn {
        FLAG.store(true, Ordering::SeqCst);
        Box::new(std::iter::empty())
    }

    struct TestSpider;

    impl Spider for TestSpider {
        fn start(&self) -> Box<dyn Iterator<Item = Request> + Send> {
            let url = "http://example.com";
            let request = Request::get(url);
            Box::new(vec![request].into_iter())
        }
    }

    struct BadSpider;

    impl Spider for BadSpider {
        fn start(&self) -> Box<dyn Iterator<Item = Request> + Send> {
            Box::new(vec![Request::default()].into_iter())
        }
    }

    #[tokio::test]
    async fn test_generate_start_requests_marks_requests_as_start() {
        let scraper = Scraper::new(Box::new(TestSpider));
        let mut requests = scraper.generate_start_requests();

        let req = requests.next().expect("Expected at least one request");
        assert!(
            req.is_start_request(),
            "Request was not marked as start request"
        );
    }

    #[test]
    #[should_panic(expected = "ValidationError: Callback cannot be empty")]
    fn test_generate_start_requests_panics_on_empty_callback() {
        let scraper = Scraper::new(Box::new(BadSpider));
        let mut requests = scraper.generate_start_requests();
        let _ = requests.next();
    }

    #[tokio::test]
    async fn test_scraper_process_response_callback() {
        let scraper = Scraper::new(Box::new(TestSpider));

        let dummy_req = Request::get("http://example.com").with_callback(dummy_callback);
        let dummy_res = http::Response::builder()
            .status(200)
            .body(Vec::new())
            .unwrap();
        let reqwest_res = ReqwestResponse::from(dummy_res);

        let download_result = DownloadResult {
            request: dummy_req,
            response: reqwest_res,
        };
        let _ = scraper.process_response(download_result).await;
        assert!(FLAG.load(Ordering::SeqCst), "Callback was not triggered");
    }
}
